<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カスタム・フルーツゲーム</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1a1a2e;
            color: #e0e0e0;
        }
        h1 {
            color: #f0f0f0;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00aaff;
        }
        #game-container {
            position: relative;
            border: 2px solid #00aaff;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
            background-color: #0f0f1a;
        }
        #game-canvas {
            display: block;
            background-image: url('https://images.unsplash.com/photo-1534796636912-3b95b3ab5986?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1171&q=80');
            background-size: cover;
            background-position: center;
        }
        #info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            font-weight: bold;
        }
        #shuffle-button {
            padding: 8px 15px;
            font-size: 0.9em;
            cursor: pointer;
            border: 1px solid #00aaff;
            border-radius: 5px;
            background-color: rgba(0, 170, 255, 0.3);
            color: white;
            transition: background-color 0.3s;
        }
        #shuffle-button:hover {
            background-color: rgba(0, 170, 255, 0.6);
        }
        .info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .info-box .label {
            font-size: 0.8em;
            color: #aaa;
        }
        .info-box span {
            font-size: 1.5em;
        }
        #game-over-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 100;
        }
        #game-over-panel h2 {
            margin-top: 0;
            font-size: 2.5em;
        }
        #restart-button {
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #ff9800;
            color: white;
            transition: background-color 0.3s;
        }
        #restart-button:hover {
            background-color: #f57c00;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>カスタム・フルーツゲーム</h1>
    <div id="game-container">
        <div id="info-panel">
            <div class="info-box">
                <span class="label">SCORE</span>
                <span id="score">0</span>
            </div>
            <button id="shuffle-button">シャッフル</button>
            <div class="info-box">
                <span class="label">TIME</span>
                <span id="timer">60</span>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <div id="game-over-panel" class="hidden">
        <h2>TIME UP!</h2>
        <p>Your Score: <span id="final-score">0</span></p>
        <button id="restart-button">もう一度遊ぶ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { Engine, Runner, World, Bodies, Composite, Body, Vector } = Matter;

            const GAME_WIDTH = 450;
            const GAME_HEIGHT = 700;
            const TSUM_RADIUS = 12.5; 
            const GAME_TIME = 60;

            const canvas = document.getElementById('game-canvas');
            const scoreElement = document.getElementById('score');
            const timerElement = document.getElementById('timer');
            const gameOverPanel = document.getElementById('game-over-panel');
            const finalScoreElement = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');
            const shuffleButton = document.getElementById('shuffle-button');
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            const FRUIT_TYPES = {
                APPLE: { id: 1, color: '#e60012', name: 'りんご', score: 100 },
                ORANGE: { id: 2, color: '#f39800', name: 'みかん', score: 120 },
                GRAPE: { id: 3, color: '#662d91', name: 'ぶどう', score: 140 },
                LEMON: { id: 4, color: '#fff100', name: 'レモン', score: 110 },
                MELON: { id: 5, color: '#8fc31f', name: 'メロン', score: 150 },
                RAINBOW: { id: 99, name: 'レインボー', isRainbow: true, score: 200 },
                TIME: { id: 98, name: 'タイム', isTime: true, score: 500, color: '#ffd700' },
                BOMB: { id: 97, name: 'ボム', isBomb: true, score: 0, color: '#333333' }
            };
            const REGULAR_FRUITS = Object.values(FRUIT_TYPES).filter(f => !f.isRainbow && !f.isTime && !f.isBomb);

            let engine, world, runner;
            let score, timeLeft, timerInterval, addTsumInterval;
            let isDragging = false;
            let currentChain = [];
            let isGameOver = false;
            let particles = [];
            let audioCtx;

            function initGame() {
                engine = Engine.create();
                world = engine.world;
                engine.gravity.y = 0; // 無重力

                runner = Runner.create();
                Runner.run(runner, engine);

                const wallOptions = { isStatic: true, render: { visible: false } };
                World.add(world, [
                    Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + 30, GAME_WIDTH, 60, wallOptions), // 床
                    Bodies.rectangle(-30, GAME_HEIGHT / 2, 60, GAME_HEIGHT, wallOptions),         // 左壁
                    Bodies.rectangle(GAME_WIDTH + 30, GAME_HEIGHT / 2, 60, GAME_HEIGHT, wallOptions), // 右壁
                    Bodies.rectangle(GAME_WIDTH / 2, -30, GAME_WIDTH, 60, wallOptions)          // 天井
                ]);
                
                score = 0;
                timeLeft = GAME_TIME;
                isGameOver = false;
                isDragging = false;
                currentChain = [];
                particles = [];
                updateScore(0);
                timerElement.textContent = timeLeft;
                gameOverPanel.classList.add('hidden');
                
                // 最初のフルーツを生成
                for (let i = 0; i < 70; i++) {
                    setTimeout(() => addTsum(true), i * 20);
                }
                
                if (addTsumInterval) clearInterval(addTsumInterval);
                if (timerInterval) clearInterval(timerInterval);

                // ゲーム開始
                setTimeout(() => {
                    addTsumInterval = setInterval(addTsum, 500);
                    startTimer();
                }, 3000);

                setupMouseEvents();
                requestAnimationFrame(gameLoop);
            }

            function addTsum(isInitial = false) {
                if (isGameOver || Composite.allBodies(world).length > 150) return;
                let type;
                const rand = Math.random();
                if (rand < 0.03) type = FRUIT_TYPES.RAINBOW;
                else if (rand < 0.06) type = FRUIT_TYPES.TIME;
                else type = REGULAR_FRUITS[Math.floor(Math.random() * REGULAR_FRUITS.length)];
                
                // ★★★ 修正点 ★★★
                // 無重力で画面外に留まらないよう、生成位置を画面内に変更
                const x = Math.random() * (GAME_WIDTH - TSUM_RADIUS * 2) + TSUM_RADIUS;
                const y = isInitial ? (Math.random() * GAME_HEIGHT * 0.8) + (GAME_HEIGHT * 0.1) : -TSUM_RADIUS * 2;
                
                const tsum = Bodies.circle(x, y, TSUM_RADIUS, {
                    restitution: 0.8, friction: 0.02, frictionAir: 0.01,
                    label: 'tsum', tsumData: type
                });
                
                // ★★★ 修正点 ★★★
                // 無重力なので、最初に少しだけランダムな力を与えて動きを出す
                 if(isInitial) {
                    Body.setVelocity(tsum, { 
                        x: (Math.random() - 0.5) * 4, 
                        y: (Math.random() - 0.5) * 4 
                    });
                 } else {
                    Body.setVelocity(tsum, { x: 0, y: 2 }); // ゲーム中は上から少しだけ落ちてくる
                 }

                World.add(world, tsum);
            }
            
            function setupAudio() {
                if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            function playPopSound() {
                if (!audioCtx) return;
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.2);
            }
            
            function createParticles(x, y, color) {
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        lifespan: 50,
                        color
                    });
                }
            }

            let isMouseSetup = false;
            function setupMouseEvents() {
                if(isMouseSetup) return;
                
                const getEventPos = e => {
                    const rect = canvas.getBoundingClientRect();
                    const evt = e.touches ? e.touches[0] : e;
                    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
                };

                const handleStart = e => {
                    e.preventDefault();
                    setupAudio();
                    if (isGameOver) return;
                    const pos = getEventPos(e);
                    const bodies = Composite.allBodies(world);
                    const clickedBomb = bodies.find(body => 
                        body.label === 'tsum' && body.tsumData.isBomb && Vector.magnitude(Vector.sub(body.position, pos)) < TSUM_RADIUS * 1.5
                    );
                    if (clickedBomb) {
                        detonateBomb(clickedBomb);
                        return;
                    }
                    const foundTsum = bodies.find(body => 
                        body.label === 'tsum' && Vector.magnitude(Vector.sub(body.position, pos)) < TSUM_RADIUS * 1.5
                    );
                    if (foundTsum) {
                        isDragging = true;
                        currentChain = [foundTsum];
                    }
                };

                const handleMove = e => {
                    e.preventDefault();
                    if (!isDragging || currentChain.length === 0) return;
                    const pos = getEventPos(e);
                    const lastTsumInChain = currentChain[currentChain.length-1];
                    const chainColorId = currentChain.find(t => !t.tsumData.isRainbow)?.tsumData.id;

                    const foundTsum = Composite.allBodies(world).find(body => {
                        if (body.label !== 'tsum' || currentChain.includes(body)) return false;
                        const isConnectable = chainColorId === undefined || body.tsumData.id === chainColorId || body.tsumData.isRainbow;
                        return isConnectable &&
                            Vector.magnitude(Vector.sub(body.position, lastTsumInChain.position)) < TSUM_RADIUS * 3.5 &&
                            Vector.magnitude(Vector.sub(body.position, pos)) < TSUM_RADIUS * 2;
                    });

                    if (foundTsum) currentChain.push(foundTsum);
                };

                const handleEnd = e => {
                    e.preventDefault();
                    if (!isDragging) return;
                    
                    if (currentChain.length >= 5) {
                        playPopSound();
                        let chainScore = 0, baseScore = 0, timeToAdd = 0;
                        const shouldCreateBomb = currentChain.length >= 7;
                        const bombTsum = shouldCreateBomb ? currentChain[currentChain.length-1] : null;

                        currentChain.forEach((tsum, index) => {
                            if (tsum === bombTsum) return;
                            baseScore += tsum.tsumData.score;
                            chainScore = baseScore * (1 + (index * 0.1));
                            if (tsum.tsumData.isTime) timeToAdd += 3;
                            createParticles(tsum.position.x, tsum.position.y, tsum.tsumData.color || 'white');
                            World.remove(world, tsum);
                        });
                        
                        if (shouldCreateBomb) bombTsum.tsumData = FRUIT_TYPES.BOMB;
                        
                        updateScore(Math.round(chainScore));
                        timeLeft += timeToAdd;
                    }
                    isDragging = false;
                    currentChain = [];
                };

                canvas.addEventListener('mousedown', handleStart);
                canvas.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);
                canvas.addEventListener('touchstart', handleStart, { passive: false });
                canvas.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleEnd);
                shuffleButton.addEventListener('click', shuffleTsums);
                isMouseSetup = true;
            }

            function detonateBomb(bomb) {
                if (!bomb || !bomb.position) return;
                playPopSound();
                const bombRadius = TSUM_RADIUS * 7;
                const bodiesInWorld = Composite.allBodies(world);
                const bodiesToRemove = [];

                bodiesInWorld.forEach(body => {
                    if (body.id !== bomb.id && body.label === 'tsum' && Vector.magnitude(Vector.sub(body.position, bomb.position)) < bombRadius) {
                        bodiesToRemove.push(body);
                    }
                });
                bodiesToRemove.push(bomb); // 爆弾自身も削除リストに

                let bombScore = 0;
                bodiesToRemove.forEach(body => {
                    bombScore += body.tsumData.score;
                    createParticles(body.position.x, body.position.y, body.tsumData.color || 'white');
                    World.remove(world, body);
                });

                updateScore(bombScore * 2);
            }

            function shuffleTsums() {
                if (isGameOver) return;
                Composite.allBodies(world).forEach(body => {
                    if (body.label === 'tsum') {
                        Body.applyForce(body, body.position, {
                            x: (Math.random() - 0.5) * 0.1,
                            y: (Math.random() - 0.5) * 0.1
                        });
                    }
                });
            }

            function updateScore(points) {
                score += points;
                scoreElement.textContent = score;
            }

            function startTimer() {
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = Math.max(0, timeLeft);
                    if (timeLeft <= 0) endGame();
                }, 1000);
            }
            
            function endGame() {
                clearInterval(timerInterval);
                clearInterval(addTsumInterval);
                isGameOver = true;
                if (runner) runner.enabled = false;
                finalScoreElement.textContent = score;
                gameOverPanel.classList.remove('hidden');
            }

            function gameLoop() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                try {
                    Composite.allBodies(world).forEach(body => {
                        if (body.label === 'tsum' && body.tsumData) {
                            const { position, angle } = body;
                            const tsumData = body.tsumData;
                            ctx.save();
                            ctx.translate(position.x, position.y);
                            ctx.rotate(angle);
                            ctx.beginPath();
                            ctx.arc(0, 0, TSUM_RADIUS, 0, 2 * Math.PI);
                            
                            if (tsumData.isRainbow) {
                                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, TSUM_RADIUS);
                                ['red','orange','yellow','green','blue','purple'].forEach((color, i) => {
                                    gradient.addColorStop(i / 5, color);
                                });
                                ctx.fillStyle = gradient;
                            } else {
                                ctx.fillStyle = tsumData.color;
                            }
                            ctx.fill();
                            
                            if (tsumData.isBomb) {
                                ctx.fillStyle = 'white';
                                ctx.font = `${TSUM_RADIUS * 1.2}px sans-serif`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('B', 0, 1);
                            } else if (tsumData.isTime) {
                                ctx.strokeStyle = 'black';
                                ctx.lineWidth = 1.5;
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                    });
                    
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i = particles.length - 1; i >= 0; i--) {
                        const p = particles[i];
                        p.x += p.vx; p.y += p.vy; p.lifespan--;
                        if (p.lifespan <= 0) {
                            particles.splice(i, 1);
                            continue;
                        }
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, Math.max(0, p.lifespan / 10), 0, 2 * Math.PI);
                        ctx.fillStyle = p.color || 'white';
                        ctx.globalAlpha = Math.max(0, p.lifespan / 50);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                    ctx.globalCompositeOperation = 'source-over';
                } catch (e) {
                    // console.error("Error in game loop:", e);
                }

                if (!isGameOver) {
                    requestAnimationFrame(gameLoop);
                }
            }
            
            restartButton.addEventListener('click', () => {
                World.clear(world);
                Engine.clear(engine);
                initGame();
            });

            initGame();
        });
    </script>
</body>
</html>