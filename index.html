<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シンプルゲーム</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f8ff;
        }
        #game-container {
            border: 2px solid #ccc;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #info-panel {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            font-weight: bold;
        }
        .info-box { text-align: center; }
        .info-box .label { font-size: 0.8em; color: #aaa; }
        .info-box span { font-size: 1.5em; }
    </style>
</head>
<body>
    <h1>シンプルゲーム</h1>
    <div id="game-container">
        <div id="info-panel">
            <div class="info-box">
                <span class="label">SCORE</span>
                <span id="score">0</span>
            </div>
            <div class="info-box">
                <span class="label">TIME</span>
                <span id="timer">60</span>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { Engine, Runner, World, Bodies, Composite, Vector } = Matter;

            const GAME_WIDTH = 400;
            const GAME_HEIGHT = 600;
            const TSUM_RADIUS = 22;
            const GAME_TIME = 60;

            const canvas = document.getElementById('game-canvas');
            const scoreElement = document.getElementById('score');
            const timerElement = document.getElementById('timer');
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // シンプルな色のツムだけを定義
            const TSUM_TYPES = [
                { id: 1, color: '#e60012', score: 100 },
                { id: 2, color: '#f39800', score: 120 },
                { id: 3, color: '#009e96', score: 140 },
                { id: 4, color: '#fff100', score: 110 },
                { id: 5, color: '#8f4e27', score: 150 },
            ];

            let engine, world, runner;
            let score, timeLeft, timerInterval, addTsumInterval;
            let isDragging = false;
            let currentChain = [];
            let isGameOver = false;

            function initGame() {
                engine = Engine.create();
                world = engine.world;
                // ★★★ 修正点 ★★★
                // 重力を元に戻す
                engine.gravity.y = 1;

                runner = Runner.create();
                Runner.run(runner, engine);

                const wallOptions = { isStatic: true, render: { visible: false } };
                World.add(world, [
                    Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + 30, GAME_WIDTH, 60, wallOptions), // 床
                    Bodies.rectangle(-30, GAME_HEIGHT / 2, 60, GAME_HEIGHT, wallOptions),       // 左壁
                    Bodies.rectangle(GAME_WIDTH + 30, GAME_HEIGHT / 2, 60, GAME_HEIGHT, wallOptions) // 右壁
                ]);
                
                score = 0; timeLeft = GAME_TIME; isGameOver = false; isDragging = false;
                currentChain = [];
                updateScore(0);
                timerElement.textContent = timeLeft;
                
                for (let i = 0; i < 30; i++) {
                    addTsum();
                }
                
                if (addTsumInterval) clearInterval(addTsumInterval);
                if (timerInterval) clearInterval(timerInterval);

                setTimeout(() => {
                    addTsumInterval = setInterval(addTsum, 800);
                    startTimer();
                }, 2000);

                setupMouseEvents();
                requestAnimationFrame(gameLoop);
            }

            function addTsum() {
                if (isGameOver || Composite.allBodies(world).length > 80) return;
                
                const type = TSUM_TYPES[Math.floor(Math.random() * TSUM_TYPES.length)];
                const tsum = Bodies.circle(
                    // 画面中央の上部から出現
                    GAME_WIDTH / 2 + (Math.random() - 0.5) * 50, -30,
                    TSUM_RADIUS, {
                    restitution: 0.3, friction: 0.2,
                    label: 'tsum', tsumData: type
                });
                World.add(world, tsum);
            }
            
            let isMouseSetup = false;
            function setupMouseEvents() {
                if(isMouseSetup) return;
                
                const getEventPos = e => {
                    const rect = canvas.getBoundingClientRect();
                    const evt = e.touches ? e.touches[0] : e;
                    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
                };
                
                // ★★★ 修正点 ★★★
                // クリック/タッチ開始の処理を、最もシンプルで確実な形に修正
                const handleStart = e => {
                    e.preventDefault();
                    if (isGameOver) return;
                    
                    const pos = getEventPos(e);
                    const bodies = Composite.allBodies(world);
                    
                    // クリックされた位置にあるツムを探す
                    const foundTsum = bodies.find(body => {
                        if (body.label !== 'tsum') return false;
                        const distance = Vector.magnitude(Vector.sub(body.position, pos));
                        // クリック判定を少し甘くする（半径の1.5倍までOK）
                        return distance < TSUM_RADIUS * 1.5;
                    });

                    // 見つかったらドラッグ開始
                    if (foundTsum) {
                        isDragging = true;
                        currentChain = [foundTsum];
                    }
                };

                const handleMove = e => {
                    e.preventDefault();
                    if (!isDragging || currentChain.length === 0) return;
                    const pos = getEventPos(e);
                    const lastTsumInChain = currentChain[currentChain.length-1];
                    const foundTsum = Composite.allBodies(world).find(body => {
                        if (body.label !== 'tsum' || currentChain.includes(body)) return false;
                        // 同じ種類で、近すぎず離れすぎていないツムを探す
                        return body.tsumData.id === lastTsumInChain.tsumData.id &&
                            Vector.magnitude(Vector.sub(body.position, lastTsumInChain.position)) < TSUM_RADIUS * 3.5 &&
                            Vector.magnitude(Vector.sub(body.position, pos)) < TSUM_RADIUS * 2;
                    });
                    if (foundTsum) currentChain.push(foundTsum);
                };

                const handleEnd = e => {
                    e.preventDefault();
                    if (!isDragging) return;
                    // 3つ以上つながっていたら消す
                    if (currentChain.length >= 3) {
                        let chainScore = 0;
                        currentChain.forEach(tsum => {
                            chainScore += tsum.tsumData.score;
                            World.remove(world, tsum);
                        });
                        updateScore(chainScore * currentChain.length); // チェイン数でスコアボーナス
                    }
                    isDragging = false;
                    currentChain = [];
                };

                canvas.addEventListener('mousedown', handleStart);
                canvas.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);
                canvas.addEventListener('touchstart', handleStart, { passive: false });
                canvas.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleEnd);
                isMouseSetup = true;
            }

            function updateScore(points) { score += points; scoreElement.textContent = score; }

            function startTimer() {
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = Math.max(0, timeLeft);
                    if (timeLeft <= 0) endGame();
                }, 1000);
            }
            
            function endGame() {
                clearInterval(timerInterval);
                clearInterval(addTsumInterval);
                isGameOver = true;
                if (runner) runner.enabled = false;
            }

            function gameLoop() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.fillStyle = '#e3f2fd';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                const bodies = Composite.allBodies(world);
                for (const body of bodies) {
                    if (body.label === 'tsum' && body.position && !isNaN(body.position.x)) {
                        const { position, angle, tsumData } = body;
                        ctx.save();
                        ctx.translate(position.x, position.y);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.arc(0, 0, TSUM_RADIUS, 0, 2 * Math.PI);
                        ctx.fillStyle = tsumData.color;
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    }
                }
                
                // つないでいる線を描画
                if (isDragging && currentChain.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(currentChain[0].position.x, currentChain[0].position.y);
                    for (let i = 1; i < currentChain.length; i++) {
                        ctx.lineTo(currentChain[i].position.x, currentChain[i].position.y);
                    }
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 10;
                    ctx.stroke();
                }

                if (!isGameOver) {
                    requestAnimationFrame(gameLoop);
                }
            }
            
            // ゲーム開始
            initGame();
        });
    </script>
</body>
</html>