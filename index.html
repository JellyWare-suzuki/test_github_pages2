<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テトリスゲーム</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            color: white;
            padding: 20px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            max-width: 800px;
            width: 100%;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #ff6d5c;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .instructions {
            background-color: #333;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            color: #ddd;
        }
        
        .game-area {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            width: 100%;
        }
        
        .tetris-board {
            background-color: #36465c;
            border: 3px solid #555;
            position: relative;
            display: block;
        }
        
        .game-info {
            flex: 1;
            max-width: 200px;
            padding: 15px;
            background-color: #333;
            border-radius: 10px;
            min-width: 180px;
        }
        
        canvas {
            display: block;
            background-color: rgba(0, 0, 0, 0.9);
            border-radius: 5px;
        }
        
        .score-display {
            font-size: 24px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        #next-piece-canvas {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            width: 100%;
            max-height: 120px;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
            color: #ff6d5c;
            font-weight: bold;
        }
        
        button {
            background-color: #ff6d5c;
            border: none;
            padding: 8px 20px;
            margin-bottom: 10px;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #ff573f;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 32px;
        }
        
        @media (max-width: 650px) {
            .game-area {
                flex-direction: column;
            }
            
            .game-info {
                width: 100%;
                max-width: none;
            }
        }

        /* エディタ用CSS */
        #editor-container {
            margin-top: 30px;
            padding: 20px;
            border: 2px solid #6c757d;
            border-radius: 10px;
            background-color: #49596a;
            display: flex;
            gap: 20px;
        }
        
        .editor-box {
            flex-basis: calc(50% - 30px);
        }
        
        .editor-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: #ff6d5c;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            background-color: #343a40;
            border-radius: 5px;
            font-family: monospace;
            color: white;
            resize: none;
        }
        
        .editor-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <header>
            <h1>テトリス</h1>
        </header>

        <main>
            <div class="instructions">
                <p><strong>遊び方:</strong></p>
                <ul>
                    <li><strong>左矢印</strong>: ブロックを左に移動</li>
                    <li><strong>右矢印</strong>: ブロックを右に移動</li>
                    <li><strong>下矢印</strong>: ブロックを速降させる</li>
                    <li><strong>上矢印</strong>: テトリミノを90度回転</li>
                </ul>
                <p><strong>目標:</strong> なるべく高いスコアを目指して！</p>
            </div>

            <div class="game-area">
                <canvas id="tetris" width="300" height="600"></canvas>
                
                <section class="game-info">
                    <h2>ゲーム情報</h2>
                    <p>現在のスコア: <span id="score">0</span></p>
                    <p>最長記録: <span id="high-score">0</span></p>
                    
                    <canvas id="next-piece-canvas" width="150" height="150"></canvas>
                    
                    <div class="controls">
                        <button id="start-button">ゲームを開始</button>
                        <button id="pause-button">一時停止</button>
                        <br>
                        <p>SPACEキーで消去</p>
                    </div>
                </section>
            </div>

            <!-- エディタ部分 -->
            <div id="editor-container" style="display: none;">
                <h2 class="editor-title">テトリスのカスタマイズ</h2>
                
                <div class="editor-box">
                    <p>ボードサイズ変更:</p>
                    <textarea id="board-config">{
  "width": 10,
  "height": 20
}</textarea>
                </div>
                
                <div class="editor-box">
                    <p>ブロックの色情報:</p>
                    <textarea id="tetromino-colors">{
  "I": "#00FFFF",
  "O": "#FFFF00",
  "T": "#9400D3",
  "S": "#00FF00",
  "Z": "#FF0000",
  "J": "#0000FF",
  "L": "#FF7F00"
}</textarea>
                </p>
                
                <div class="editor-buttons">
                    <button id="save-config">設定を保存</button>
                    <button id="load-config">設定を読み込む</button>
                    <button id="reset-editor">元に戻る</button>
                </div>
            </div>
        </main>
    </div>

    <script>
        // テトリスの基本構成
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextPieceCanvas = document.createElement('canvas').getContext('2d');
        
        // キャンバスサイズを設定
        let CELL_SIZE = 30;
        if (window.innerWidth < 480) {
            CELL_SIZE = Math.floor(window.innerHeight / 65);
        }
        canvas.width = 10 * CELL_SIZE + 7; // ボードの幅と余白
        canvas.height = 20 * CELL_SIZE + 7; // ボードの高さと余白
        
        nextPieceCanvas.canvas.width = (4 * CELL_SIZE) / 2;
        nextPieceCanvas.canvas.height = (4 * CELL_SIZE);
        
        const BLOCK_WIDTH = CELL_SIZE - 1;
        const BLOCK_HEIGHT = CELL_SIZE - 1;
        
        // ゲーム状態
        let scoreElement, highScoreElement, startButton, pauseButton;
        let board = []; // ボードの状態を保持する配列
        let currentPiece; // 現在のテトリミノ
        let nextPiece;    // 次のテトリミノ
        let isPlaying = false;
        let gameOverCellCount = 0;
        
        // カラーマップ（ブロックタイプと色を対応させる）
        const COLORS = {
            'I': '#00FFFF',
            'O': '#FFFF00',
            'T': '#9400D3',
            'S': '#00FF00',
            'Z': '#FF0000',
            'J': '#0000FF',
            'L': '#FF7F00'
        };
        
        // テトリミノの形状を定義
        const SHAPES = {
            'I': [
                [1, 1, 1, 1],
            ],
            
            'O': [
                [1, 1],
                [1, 1]
            ],
            
            'T': [
                [0, 1, 0],
                [1, 1, 1],
            ],
            
            'S': [
                [0, 0, 0],
                [2, 2, 0],
                [0, 2, 2]
            ],
            
            'Z': [
                [3, 3, 0],
                [0, 3, 3],
            ],
            
            'J': [
                [4, 4],
                [4, 0],
                [4, 0]
            ],
            
            'L': [
                [5, 0],
                [5, 0],
                [5, 5]
            ]
        };
        
        // テトリミノの生成
        function getRandomPiece() {
            const pieces = Object.keys(SHAPES);
            return {
                shape: SHAPES[pieces[Math.floor(Math.random() * pieces.length)]],
                type: pieces[Math.floor(Math.random() * pieces.length)],
                row: 0,
                col: Math.floor(board[0].length / 2) - Math.floor(SHAPES[pieces[0]].length / 2),
            };
        }
        
        // 初期化
        function initGame() {
            scoreElement = document.getElementById('score');
            highScoreElement = document.getElementById('high-score');
            
            startButton.addEventListener('click', () => {
                if (!isPlaying) {
                    isPlaying = true;
                    createBoard();
                    currentPiece = getRandomPiece();
                    nextPiece = getRandomPiece();
                    
                    // 次のピースを表示する領域の準備
                    drawNextPiece(nextPiece);
                    
                    scoreElement.textContent = '0';
                    
                    requestAnimationFrame(gameLoop);
                } else {
                    startButton.textContent = "再開";
                }
            });
            
            pauseButton.addEventListener('click', () => {
                if (isPlaying) {
                    isPlaying = false;
                    cancelAnimationFrame(animationId);
                    drawPauseScreen();
                } else {
                    isPlaying = true;
                    requestAnimationFrame(gameLoop);
                }
            });
        }
        
        // ボードの作成
        function createBoard() {
            board = [];
            
            for (let row = 0; row < canvas.height / CELL_SIZE - 1; row++) {
                const line = Array(canvas.width / CELL_SIZE).fill([0, '']);
                board.push(line);
            }
        }
        
        // テトリミノを描画
        function drawPiece(piece) {
            piece.shape.forEach((row, rowIndex) => {
                let y = piece.row * CELL_SIZE + 2;
                
                row.forEach((cell, colIndex) => {
                    if (cell !== 0 && cell !== ' ') {
                        ctx.fillStyle = COLORS[piece.type];
                        
                        // カラーが指定されていない場合はデフォルトの色を使用
                        let colorValue = cell > SHAPES['I'][0].length ? 
                                        '#9400D3' : (cell === 2 || cell === 3) ? 
                                        COLORS[piece.type] : CELL_SIZE + 'px #ffffff';
                        
                        // テキスト描画の場合は色を変更
                        if (typeof piece.shape[rowIndex][colIndex] === 'string') {
                            ctx.font = `bold ${CELL_SIZE}px Arial`;
                            ctx.fillStyle = colorValue;
                            ctx.fillText(
                                String.fromCharCode(65 + parseInt(piece.row)), 
                                colIndex * CELL_SIZE, 
                                rowIndex * CELL_SIZE
                            );
                        } else if (cell !== 0 && cell !== ' ') {
                            // ボードの色を適用する場合は、通常のブロック描画
                            ctx.fillRect(
                                piece.col * CELL_SIZE + row[colIndex] === 2 || row[colIndex] === 3 ? 
                                    BOARD_LEFT : x, 
                                (piece.row + rowIndex) * CELL_SIZE, 
                                BLOCK_WIDTH, 
                                BLOCK_HEIGHT
                            );
                            
                            // テキスト描画の場合は色を変更
                            if (typeof piece.shape[rowIndex][colIndex] !== 'number') {
                                ctx.font = `bold ${CELL_SIZE}px Arial`;
                                ctx.fillStyle = colorValue;
                                ctx.fillText(
                                    String.fromCharCode(65 + parseInt(piece.row)), 
                                    colIndex * CELL_SIZE, 
                                    rowIndex * CELL_SIZE
                                );
                            }
                        } else if (cell === 0) {
                            // 空のセルは背景と同じ色で描画しない
                        }
                    }
                });
            });
        }
        
        const BOARD_LEFT = canvas.width - BOARD_WIDTH + 7;
        let animationId;

        function gameLoop() {
            update();
            
            drawBoard();
            if (currentPiece) {
                drawPiece(currentPiece);
            }
            
            // ボード上に固定されたブロックを描画
            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellValue = typeof cell === 'number' ? 
                                    { ...cell } : {...cell};
                    
                    if (typeof cell !== 'string') {
                        // 数値で表されたブロックは色付きで描画
                        ctx.fillStyle = COLORS[cell];
                        
                        // ボーナスブロック（中央付近）の強調表示
                        const isCenterArea = rowIndex >= 1 && colIndex > canvas.width / CELL_SIZE - 4;
                        if (isCenterArea) {
                            ctx.globalAlpha = 0.6; // 半透明で描画
                            
                            // 特殊な色を設定（中央付近はもっと濃い）
                            const centerColors = {
                                'I': '#00FFFF',
                                'O': '#FFFF00'
                            };
                            
                            if (centerColors[cell]) ctx.fillStyle = centerColors[cell];
                        }
                        
                        ctx.fillRect(
                            colIndex * CELL_SIZE,
                            rowIndex * CELL_SIZE + 2, // +2は上余白の調整
                            BLOCK_WIDTH,
                            BLOCK_HEIGHT
                        );
                        
                        // ボーナスブロックに星印を表示
                        if (isCenterArea && row[cell] === 'BONUS') {
                            ctx.fillStyle = '#00FF7F';
                            ctx.font = `bold ${CELL_SIZE / 2}px Arial`;
                            ctx.fillText(
                                '*', 
                                colIndex * CELL_SIZE + CELL_SIZE/4, 
                                rowIndex * CELL_SIZE + (BLOCK_HEIGHT - CELL_SIZE)/2
                            );
                        }
                    } else if (cell === ' ') {
                        // 空のセルは描画しない
                    } else {
                        // 文字で表されたブロックは色付きテキストで描画
                        ctx.font = `bold ${CELL_SIZE}px Arial`;
                        ctx.fillStyle = COLORS[cell];
                        
                        const textX = colIndex * CELL_SIZE;
                        const textY = (rowIndex + 1) * CELL_SIZE - row[colIndex] === 'BONUS' ? 
                                    rowIndex * CELL_SIZE : rowIndex * CELL_SIZE;
                                    
                        if (cell === '*') {
                            ctx.fillStyle = '#00FF7F';
                        } else {
                            // 数値に変換されたブロックタイプを色で表示
                            let charCode = String.fromCharCode(65 + parseInt(cell));
                            
                            // カラーマップに基づいて色を設定
                            const colorKey = { 
                                'I': cell === 0 ? '#9400D3' : COLORS.I,
                                'O': cell === 0 ? '#FFFF00' : COLORS.O,
                            };
                            
                            if (cell > SHAPES['I'][0].length) {
                                ctx.fillStyle = COLORS[cell];
                            } else {
                                // テキストを中央余白のエリアに強調表示
                                const isCenterTextCell = typeof cell === 'string' && 
                                                    rowIndex >= 1 && colIndex < canvas.width / CELL_SIZE;
                                if (isCenterArea && row[cell] !== '*') {
                                    ctx.globalAlpha = 0.6; // 半透明で描画
                                }
                                
                                switch (cell) {
                                    case 'I':
                                        charCode = "I";
                                        break;
                                    case 'O':
                                        charCode = "O";
                                        break;
                                    default:
                                        charCode = String.fromCharCode(65 + parseInt(cell));
                                }
                                
                                // テキストを描画
                                ctx.fillText(
                                    charCode, 
                                    colIndex * CELL_SIZE,
                                    rowIndex * CELL_SIZE + 2 + cell === 'BONUS' ? -CELL_SIZE : BLOCK_HEIGHT/3
                                );
                            }
                        }
                    }
                });
            });
        }

        // ゲームの更新処理（ゲームの進行と論理を制御）
        function update() {
            // テトリミノが消滅したかどうか判定して、ゲームオーバーをチェック
            if (!isPlaying) return;
            
            moveDown(); // 自動落下開始
            
            if (checkCollision(currentPiece.shape, currentPiece.row + 1)) {
                lockPiece();
                
                // スコアリングロジック
                const clearedRows = checkClearLines();
                updateScore(clearedRows);
                
                gameOverCellCount += clearedRows * clearedRows;
                scoreElement.textContent = Math.floor(gameOverCellCount / (clearedRows+2));
            }
        }

        function drawBoard() {
            // ボードの上余白
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${CELL_SIZE}px Arial`;
            
            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellValue = typeof cell === 'number' ? 
                                    { ...cell } : {...cell};
                    
                    if (typeof cell !== 'string') {
                        // 数値で表されたブロックは色付きで描画
                        ctx.fillStyle = COLORS[cell];
                        
                        // ボーナスエリアのブロックを強調表示（中央付近）
                        const isCenterArea = colIndex > canvas.width / CELL_SIZE - 4;
                        
                        if (isCenterArea && row[cell] === 'BONUS') {
                            ctx.globalAlpha = 0.8; // 半透明で描画
                            
                            // 特殊な色を設定（中央付近はもっと濃い）
                            const centerColors = {
                                'I': '#00FFFF',
                                'O': '#FFFF00'
                            };
                            
                            if (centerColors[cell]) ctx.fillStyle = COLORS[centerColors[cell]];
                        } else {
                            // デフォルトの色を適用
                            let colorValue;
                            
                            // 数値で表されたブロックはカラーマップに基づいて描画
                            if (typeof cell === 'number') {
                                if (cell > 0) {
                                    ctx.fillStyle = COLORS[cell];
                                    ctx.fillRect(
                                        colIndex * CELL_SIZE,
                                        rowIndex * CELL_SIZE + 2, 
                                        BLOCK_WIDTH, 
                                        BLOCK_HEIGHT
                                    );
                                    // ボーナスブロックの場合、色を変更して強調表示
                                    if (typeof cell === 'number' && row[cell] === 'BONUS') {
                                        colorValue = { ...cell };
                                        ctx.fillStyle = '#00FF7F';
                                        ctx.font = `bold ${CELL_SIZE}px Arial`;
                                        ctx.fillText(
                                            '*', 
                                            colIndex * CELL_SIZE, 
                                            rowIndex * CELL_SIZE + (BLOCK_HEIGHT - CELL_SIZE)/2
                                        );
                                    }
                                } else {
                                    // 空のセルは背景と同じ色で描画しない
                                    return;
                                }
                            }
                            
                        });
                    }
                });
            });

        function drawNextPiece(piece) {
            nextPieceCanvas.clearRect(0, 0, (4 * CELL_SIZE), BOARD_LEFT);
            
            const shape = piece.shape;
            let typeCellSize = BLOCK_WIDTH + cellSpacing; // ブロックのサイズ
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] !== 0) {
                        nextPieceCanvas.fillStyle = COLORS[piece.type];
                        // ボーラスピースは青色で強調
                        const colorValue = COLORS[piece.type]; 
                        let bonusColorValue;
                        
                        if ((piece.row + row >= BOARD_LEFT / CELL_SIZE || piece.col + colIndex) && 
                            (cell === 2 || cell === 3)) {
                            // ボーナスブロックの判定
                            if (Math.random() < 0.5) {
                                bonusColor = `hsl( ${parseInt(COLORS[piece.type].slice(-6))}, 100%, 80%)`;
                                ctx.fillStyle = COLORS[piece.type] = bonusColor;
                                
                                // 特殊なブロックをマーク
                                board[piece.row + row][piece.col + colIndex * piece.shape.length] = 
                                        {row: String.fromCharCode(65 + piece.row), 'BONUS'};
                            }
                        }
                            
                        nextPieceCanvas.fillStyle = COLORS[piece.type];
                        ctx.fillRect(
                            BOARD_LEFT,
                            (nextPiece.row + row) * CELL_SIZE, // 次のピースを描画
                            typeCellSize,
                            colIndex * CELL_SIZE + row[colIndex] === 2 || row[colIndex] === 3 ? 
                                BLOCK_HEIGHT : cellHeight; // セルサイズ+余白のブロック高さはBLOCK_HEIGHTで指定しているので調整不要
                    
                    }
                }
            });
            
        }

        function drawBoard() {
            // ボードを描画
            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (typeof cell === 'number' && typeof cell !== 'BONUS') {
                        const cellValue = { ...cell };
                        
                        if (cell > 0 && cell < COLORS.length) {
                            // 数値で表されたブロックは色付きで描画
                            ctx.fillStyle = COLORS[cell];
                            
                            // ボーナスエリアのブロックを強調表示する場合
                            const isCenterArea = colIndex >= canvas.width / CELL_SIZE - 4;
                            if (isCenterArea) {
                                ctx.globalAlpha = 0.6; // 半透明で描画
                                
                                // 特殊な色を設定（中央付近はもっと濃い）
                                let bonusColors = { 'I': '#00FFFF', 'O':'#FFFF0}
                                
                                if (bonusColors[cell]) {
                                    ctx.fillStyle = COLORS[cell];
                                } else {
                                    // デフォルトの色に戻す
                                    ctx.globalAlpha = 1;
                                    ctx.fillStyle = COLORS[cell];
                                }
                            }
                            
                            ctx.fillRect(
                                colIndex * CELL_SIZE,
                                rowIndex * CELL_SIZE + BOARD_TOP, 
                                BLOCK_WIDTH, 
                                BLOCK_HEIGHT
                            );
                        } else if (typeof cell === 'string' && !(cell === '')) {
                            // 文字で表されたブロックはテキストを適用して描画
                        }
                    }
                });
            });

        }

        function drawBoard() {
            // ボードの背景（余白を含む）
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 上の文字列表示用の余白
            const BOARD_TOP = BOARD_HEIGHT + 7;
            drawBoard();
        }
        
        let cellCountForBonus;

        function lockPiece() {
            if (!isPlaying || currentPiece === null) return;
            
            // 現在のピースを固定してボードにブロックとして追加
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (typeof cell === 'number') {
                        // 数値で表されたブロックは色付きで描画
                        const blockValue = typeof board[row][col] === 'number' ? 
                                        { ...board[row][col]} : {...board[row][col]};
                        
                        // ボーナスブロックかどうかの判定
                        if (rowIndex > 0 && colIndex >= cellCountForBonus) {
                            board[row + rowIndex - 1][col] = rowIndex * (currentPiece.row+rowIndex);
                    }
                });
            } else {
                // 数値で表されたブロックはそのまま追加
                board[row].forEach((cell, index) => {
                    if (typeof cell === 'number') {
                        const blockValue = { ...cell };
                        
                        if (cell > 0 && cell < COLORS.length) {
                            board[row][col] += row[colIndex];
                            board[row][colIndex + currentPiece.col * row] = cell;
                        }
                    }
                });
            });

        }

        function lockPiece() {
            const blockValue = typeof board[currentPiece.row][currentPiece.shape.length - 1 + col] === 'number' ? 
                    { ...board[currentPiece.row + rowIndex]} : String.fromCharCode(65 + cell);
            
            // ボードの行と列を固定してブロックを固定する
        }

        
        function lockBoard() {
            if (!isはるか) return;
        }
        
        // スコアリングロジックの修正部分
            
        }

        function updateScore(clearedRows, score) {
            let points = 0;
            
            for (let i=1; i <= clearedRows.length; i++) {
                const rowNumber = BOARD_LEFT / CELL_SIZE * 4 + cellSpacing;
                
                // スコアの更新と表示
                score += clearedRows * clearedRows;
                return Math.floor(CELLS * clearedRows);
            }
        }

        function updateScore(clearedLines) {
            let newRows = [2,3]; // 基本点数
            
            for (let i = 0; i < clearedBlocks.length; i++) {
                if (clearedRows >= 1 && clearedRows <=4){
                    score += clearedCells * row;
                    
            }
        }

        
        function checkClear(boardRow + piece, currentPiece) {
            // ボードがクリーンラインの行数を返す
        });

        init();
        
        document.getElementById('tetris').onclick = lockPiece; 
    </script>

    <style>
        /* スタート画面とゲームオーバー時の背景 */
        #board {
            background-color: rgba(0, 255, 255, 1); // 背景
        }
        
        .tetris-container {
            width: 300px;
            height: 450px;
            background-color: #00f00;
            position: relative;
            margin: auto;
            border: none; /* 外のboardに色をつけて */
        }

        // テトリオスの基本的な要素はここまでで作成し、後はJavaScriptでゲームロジックを実装する
    </style>
</style>

This is a preview of how your code might look. You must fix the broken HTML and CSS to create a complete, working Tetris game in one folder.

To make this clear, I'll try my best to reconstruct the entire Tetris game with all necessary components within a single folder.
We are going to use pure JavaScript without using any external libraries or frameworks (like jQuery) for simplicity. Since you requested multiple features and fixes, it might be too complex for a simple example, so let's focus on creating the basic structure of the game including a grid-based board, tetromino shapes, falling pieces, collision detection, line clearing, and user interaction.

However, I notice there are many inconsistencies in your code. Let me restructure this to create a complete Tetris game from scratch with minimal dependencies (only one folder) using pure HTML/JS/CSS/JS without any external libraries.

# フォルダでテトリスをHTMLで作成するには、以下の手順で1フォルダで実装します。

まず，フォルダを作成し，その中にあるtetris.htmlというファイル名のテトリスゲームを作成します。HTML, CSS, JavaScriptが全て一つのフォルダ内に配置されるようにします。

# エラーメッセージ
        
申し訳ありませんが、ごめんなさい、あなたは「テトリスを1フォルダで作成してほしい」という要求でHTMLでテトリスを作成することをお求めですか？ その場合、以下のようなファイル構成で実装できます。

