<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ツムツム風ゲーム</title>

    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f8ff;
            color: #333;
        }

        h1 {
            color: #555;
            margin-bottom: 10px;
        }

        #game-container {
            position: relative;
            border: 2px solid #ccc;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            background-color: #fff;
        }

        #game-canvas {
            display: block;
            background-image: url('https://www.transparenttextures.com/patterns/cubes.png');
            background-color: #e3f2fd;
        }

        #info-panel {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            font-weight: bold;
        }

        .info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .info-box .label {
            font-size: 0.8em;
            color: #aaa;
        }

        .info-box span {
            font-size: 1.5em;
        }

        #game-over-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #game-over-panel h2 {
            margin-top: 0;
            font-size: 2.5em;
        }

        #restart-button {
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #ff9800;
            color: white;
            transition: background-color 0.3s;
        }

        #restart-button:hover {
            background-color: #f57c00;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>ツムツム風ゲーム</h1>
    <div id="game-container">
        <div id="info-panel">
            <div class="info-box">
                <span class="label">SCORE</span>
                <span id="score">0</span>
            </div>
            <div class="info-box">
                <span class="label">TIME</span>
                <span id="timer">60</span>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <div id="game-over-panel" class="hidden">
        <h2>TIME UP!</h2>
        <p>Your Score: <span id="final-score">0</span></p>
        <button id="restart-button">もう一度遊ぶ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Matter.js モジュールのエイリアス設定 ---
            const { Engine, Render, Runner, World, Bodies, Composite, Events, Vector, Bounds } = Matter;

            // --- ゲームの基本設定 ---
            const GAME_WIDTH = 450;
            const GAME_HEIGHT = 700;
            const INFO_PANEL_HEIGHT = 60; // 情報パネルの高さ
            const TSUM_RADIUS = 25; // ツムの半径
            const GAME_TIME = 60; // ゲーム時間（秒）

            // --- DOM要素の取得 ---
            const canvas = document.getElementById('game-canvas');
            const scoreElement = document.getElementById('score');
            const timerElement = document.getElementById('timer');
            const gameOverPanel = document.getElementById('game-over-panel');
            const finalScoreElement = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');
            
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // --- ツムの種類を定義 ---
            const TSUM_TYPES = [
                { id: 1, color: '#e60012', score: 100 }, // ミッキー風
                { id: 2, color: '#f39800', score: 120 }, // プーさん風
                { id: 3, color: '#009e96', score: 140 }, // ドナルド風
                { id: 4, color: '#fff100', score: 110 }, // プルート風
                { id: 5, color: '#8f4e27', score: 150 }, // グーフィー風
            ];

            // --- ゲームの状態変数 ---
            let engine, world, runner;
            let score, timeLeft, timerInterval, addTsumInterval;
            let isDragging = false;
            let currentChain = [];
            let lastTsum = null;
            let isGameOver = false;

            // --- ゲーム初期化関数 ---
            function initGame() {
                // --- 1. 物理エンジンのセットアップ ---
                engine = Engine.create();
                world = engine.world;
                engine.gravity.y = 1.2;

                // --- 2. Runnerの作成 ---
                runner = Runner.create();
                Runner.run(runner, engine);

                // --- 3. 壁の作成 ---
                const wallOptions = { isStatic: true, render: { visible: false } };
                World.add(world, [
                    Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + 30, GAME_WIDTH, 60, wallOptions), // 床
                    Bodies.rectangle(-30, GAME_HEIGHT / 2, 60, GAME_HEIGHT, wallOptions),         // 左壁
                    Bodies.rectangle(GAME_WIDTH + 30, GAME_HEIGHT / 2, 60, GAME_HEIGHT, wallOptions) // 右壁
                ]);
                
                // --- 4. ゲーム状態のリセット ---
                score = 0;
                timeLeft = GAME_TIME;
                isGameOver = false;
                isDragging = false;
                currentChain = [];
                lastTsum = null;
                updateScore(0);
                timerElement.textContent = timeLeft;
                gameOverPanel.classList.add('hidden');
                
                // --- 5. 最初のツムを生成 ---
                for (let i = 0; i < 25; i++) {
                    setTimeout(() => addTsum(true), i * 50);
                }
                
                // --- 6. 定期的な処理を開始 ---
                // 既存のインターバルをクリア
                if (addTsumInterval) clearInterval(addTsumInterval);
                if (timerInterval) clearInterval(timerInterval);

                setTimeout(() => {
                    addTsumInterval = setInterval(() => addTsum(), 800);
                    startTimer();
                }, 2000);

                // --- 7. イベントリスナーのセットアップ ---
                setupMouseEvents();

                // --- 8. ゲームループの開始 ---
                requestAnimationFrame(gameLoop);
            }

            // --- ツムを追加する関数 ---
            function addTsum(isInitial = false) {
                if (isGameOver || Composite.allBodies(world).length > 60) return;

                const type = TSUM_TYPES[Math.floor(Math.random() * TSUM_TYPES.length)];
                const x = isInitial ? Math.random() * (GAME_WIDTH - TSUM_RADIUS * 2) + TSUM_RADIUS : Math.random() * 100 + (GAME_WIDTH/2 - 50);
                
                const tsum = Bodies.circle(x, -30, TSUM_RADIUS, {
                    restitution: 0.4,
                    friction: 0.1,
                    label: 'tsum',
                    tsumData: type
                });
                World.add(world, tsum);
            }

            // --- マウスイベントの処理 ---
            let isMouseSetup = false;
            function setupMouseEvents() {
                 if(isMouseSetup) return; // 重複登録を防ぐ

                const startHandler = (e) => {
                    e.preventDefault();
                    const event = e.touches ? e.touches[0] : e;
                    handleDragStart(event);
                };
                const moveHandler = (e) => {
                    e.preventDefault();
                    const event = e.touches ? e.touches[0] : e;
                    handleDragMove(event);
                };
                const endHandler = (e) => {
                    e.preventDefault();
                    handleDragEnd();
                };

                canvas.addEventListener('mousedown', startHandler);
                canvas.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', endHandler);
                
                canvas.addEventListener('touchstart', startHandler);
                canvas.addEventListener('touchmove', moveHandler);
                window.addEventListener('touchend', endHandler);

                isMouseSetup = true;
            }

            function getMousePos(event) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }

            function handleDragStart(event) {
                if (isGameOver) return;
                const mousePos = getMousePos(event);
                const bodies = Composite.allBodies(world);
                const foundTsum = bodies.find(body => 
                    body.label === 'tsum' && Vector.magnitude(Vector.sub(body.position, mousePos)) < TSUM_RADIUS
                );

                if (foundTsum) {
                    isDragging = true;
                    currentChain = [foundTsum];
                    lastTsum = foundTsum;
                }
            }

            function handleDragMove(event) {
                if (!isDragging) return;
                const mousePos = getMousePos(event);
                const bodies = Composite.allBodies(world);
                const foundTsum = bodies.find(body => 
                    body.label === 'tsum' && 
                    !currentChain.includes(body) &&
                    body.tsumData.id === lastTsum.tsumData.id &&
                    Vector.magnitude(Vector.sub(body.position, lastTsum.position)) < TSUM_RADIUS * 2.5 &&
                    Vector.magnitude(Vector.sub(body.position, mousePos)) < TSUM_RADIUS
                );

                if (foundTsum) {
                    currentChain.push(foundTsum);
                    lastTsum = foundTsum;
                }
            }

            function handleDragEnd() {
                if (!isDragging) return;

                if (currentChain.length >= 3) {
                    let chainScore = 0;
                    let baseScore = 0;
                    currentChain.forEach((tsum, index) => {
                        baseScore += tsum.tsumData.score;
                        chainScore = baseScore * (1 + (index * 0.1));
                        World.remove(world, tsum);
                    });
                    updateScore(Math.round(chainScore));
                }

                isDragging = false;
                currentChain = [];
                lastTsum = null;
            }

            // --- スコア更新 ---
            function updateScore(points) {
                score += points;
                scoreElement.textContent = score;
            }

            // --- タイマー処理 ---
            function startTimer() {
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }, 1000);
            }
            
            // --- ゲーム終了処理 ---
            function endGame() {
                clearInterval(timerInterval);
                clearInterval(addTsumInterval);
                isGameOver = true;
                runner.enabled = false;
                
                finalScoreElement.textContent = score;
                gameOverPanel.classList.remove('hidden');
            }

            // --- ゲームループ（描画処理） ---
            function gameLoop() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                const bodies = Composite.allBodies(world);

                bodies.forEach(body => {
                    if (body.label === 'tsum') {
                        const { position, angle } = body;
                        ctx.save();
                        ctx.translate(position.x, position.y);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.arc(0, 0, TSUM_RADIUS, 0, 2 * Math.PI);
                        
                        // チェインに含まれているツムを少し光らせる
                        if (currentChain.includes(body)) {
                            ctx.fillStyle = 'white';
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(0, 0, TSUM_RADIUS * 0.9, 0, 2 * Math.PI);
                        }

                        ctx.fillStyle = body.tsumData.color;
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        ctx.restore();
                    }
                });

                if (isDragging && currentChain.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(currentChain[0].position.x, currentChain[0].position.y);
                    currentChain.forEach(tsum => {
                        ctx.lineTo(tsum.position.x, tsum.position.y);
                    });
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 15;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }
                
                if (!isGameOver) {
                    requestAnimationFrame(gameLoop);
                }
            }
            
            // --- リスタート処理 ---
            restartButton.addEventListener('click', () => {
                World.clear(world);
                Engine.clear(engine);
                initGame();
            });

            // --- ゲーム開始 ---
            initGame();
        });
    </script>
</body>
</html>