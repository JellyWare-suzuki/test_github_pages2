<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>強化版 ツムツム風ゲーム</title>
  <style>
    body {
      background: #111;
      color: #fff;
      text-align: center;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin: 20px 0 5px;
    }
    #info {
      margin-bottom: 10px;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(14, 30px);  /* 列を増やす */
      grid-template-rows: repeat(12, 30px);     /* 行を増やす */
      gap: 2px;
      justify-content: center;
      margin: 0 auto;
      width: max-content;
    }
    .cell {
      width: 30px;
      height: 30px;
      background-color: gray;
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    .selected {
      outline: 2px solid white;
    }
    .sparkle {
      position: absolute;
      width: 30px;
      height: 30px;
      pointer-events: none;
      background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 60%);
      transform: scale(0);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
    }
    .sparkle.active {
      transform: scale(1);
      opacity: 1;
    }
    .bomb {
      border: 2px solid white;
    }
    #timer {
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>強化版ミニ・ツムツム風ゲーム</h1>
  <div id="info">
    <span id="timer">残り時間: <span id="time">60</span> 秒</span>
    &nbsp;|&nbsp;
    <span id="score">得点: 0</span>
  </div>
  <div id="game"></div>

  <audio id="pop-sound">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YSQAAAAA" type="audio/wav">
    <!-- 簡易無音音源。実運用時は適切な “ポン！” 音声ファイルを指定 -->
  </audio>

  <script>
    const ROWS = 12;
    const COLS = 14;
    const COLORS = ['red','blue','green','yellow','purple'];
    const PROB_RAINBOW = 0.02;  // 虹ツム出現確率
    const PROB_TIME = 0.01;     // タイムツム出現確率

    const game = document.getElementById('game');
    const grid = [];
    let selected = [];
    let isDragging = false;
    let score = 0;
    let timeLeft = 60;
    let timerInterval = null;

    function getCell(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null;
      return grid[r][c];
    }
    function areAdjacent(a, b) {
      const r1 = +a.dataset.r, c1 = +a.dataset.c;
      const r2 = +b.dataset.r, c2 = +b.dataset.c;
      return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
    }

    function playPopSound() {
      const audio = document.getElementById('pop-sound');
      audio.currentTime = 0;
      audio.play().catch(e => {
        // 再生できない場合は無視
      });
    }

    function makeCell(r, c) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      // 色をランダムに決定。ただし一定確率で虹 or タイムツム
      let color;
      const rnd = Math.random();
      if (rnd < PROB_TIME) {
        color = 'gold';  // タイムツム
        cell.dataset.type = 'time';
      } else if (rnd < PROB_TIME + PROB_RAINBOW) {
        color = 'rainbow';
        cell.dataset.type = 'rainbow';
      } else {
        color = COLORS[Math.floor(Math.random() * COLORS.length)];
        cell.dataset.type = 'normal';
      }
      cell.dataset.color = color;
      cell.style.backgroundColor = color === 'rainbow' ? 'white' : color;
      game.appendChild(cell);

      const sparkle = document.createElement('div');
      sparkle.className = 'sparkle';
      cell.appendChild(sparkle);

      return cell;
    }

    function initGrid() {
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          const cell = makeCell(r, c);
          grid[r][c] = cell;
        }
      }
    }

    function clearSelection() {
      selected.forEach(cell => cell.classList.remove('selected'));
      selected = [];
    }

    function showSparkle(cell) {
      const sp = cell.querySelector('.sparkle');
      sp.classList.add('active');
      setTimeout(() => {
        sp.classList.remove('active');
      }, 300);
    }

    function collapseColumn(c) {
      for (let r = ROWS - 1; r >= 0; r--) {
        if (!grid[r][c].dataset.color) {
          // 空きがあれば上から詰める
          for (let rr = r - 1; rr >= 0; rr--) {
            if (grid[rr][c].dataset.color) {
              grid[r][c].dataset.color = grid[rr][c].dataset.color;
              grid[r][c].dataset.type = grid[rr][c].dataset.type;
              grid[r][c].style.backgroundColor = (grid[r][c].dataset.type === 'rainbow' ? 'white' : grid[r][c].dataset.color);
              break;
            }
          }
        }
      }
      // 上行を補充
      for (let r = 0; r < ROWS; r++) {
        if (!grid[r][c].dataset.color) {
          const newCell = grid[r][c];
          // 新しいツム生成
          let color, type;
          const rnd = Math.random();
          if (rnd < PROB_TIME) {
            type = 'time'; color = 'gold';
          } else if (rnd < PROB_TIME + PROB_RAINBOW) {
            type = 'rainbow'; color = 'rainbow';
          } else {
            type = 'normal'; color = COLORS[Math.floor(Math.random() * COLORS.length)];
          }
          newCell.dataset.type = type;
          newCell.dataset.color = color;
          newCell.style.backgroundColor = (type === 'rainbow' ? 'white' : color);
        }
      }
    }

    function removeSelected() {
      if (selected.length >= 5) {
        // “ボム”処理
        let isBomb = false;
        if (selected.length >= 7) {
          // 最後のセルをボムにする
          const last = selected[selected.length - 1];
          last.dataset.type = 'bomb';
          last.dataset.color = 'black';
          last.style.backgroundColor = 'black';
          last.classList.add('bomb');
          isBomb = true;
        }

        // 通常消去 or ボム爆発
        selected.forEach(cell => {
          // sparkle エフェクト
          showSparkle(cell);
        });
        playPopSound();

        if (isBomb) {
          // 爆発：選択セルの周囲 1 セルを全て消す
          const last = selected[selected.length - 1];
          const lr = +last.dataset.r, lc = +last.dataset.c;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nb = getCell(lr + dr, lc + dc);
              if (nb && nb.dataset.color) {
                nb.dataset.color = '';
                nb.dataset.type = '';
              }
            }
          }
        } else {
          // 通常消し：選択されたセルを空に
          selected.forEach(cell => {
            cell.dataset.color = '';
            cell.dataset.type = '';
          });
        }

        // タイムツム処理：選択中に time があれば時間追加
        selected.forEach(cell => {
          if (cell.dataset.type === 'time') {
            timeLeft += 3;
          }
        });

        // スコア追加
        score += selected.length * 10;

        // 各列落とす
        for (let c = 0; c < COLS; c++) {
          collapseColumn(c);
        }
      }
      clearSelection();
      updateInfo();
    }

    function updateInfo() {
      document.getElementById('score').textContent = '得点: ' + score;
    }

    function onMouseDown(e) {
      if (!e.target.classList.contains('cell')) return;
      isDragging = true;
      clearSelection();
      const cell = e.target;
      cell.classList.add('selected');
      selected.push(cell);
    }
    function onMouseMove(e) {
      if (!isDragging) return;
      if (!e.target.classList.contains('cell')) return;
      const curr = e.target;
      const last = selected[selected.length - 1];
      if (curr !== last && areAdjacent(curr, last)) {
        // 虹ツムはどの色ともつながる
        const lastColor = last.dataset.color;
        const currColor = curr.dataset.color;
        const currType = curr.dataset.type;
        if (!selected.includes(curr)) {
          if (currType === 'rainbow' || last.dataset.type === 'rainbow' || currColor === lastColor) {
            curr.classList.add('selected');
            selected.push(curr);
          }
        }
      }
    }
    function onMouseUp(e) {
      isDragging = false;
      removeSelected();
    }

    function startTimer() {
      timerInterval = setInterval(() => {
        timeLeft--;
        document.getElementById('time').textContent = timeLeft;
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          alert('時間切れ！ 得点: ' + score);
          // リロードして再スタート
          location.reload();
        }
      }, 1000);
    }

    // 初期化
    initGrid();
    updateInfo();
    startTimer();

    game.addEventListener('mousedown', onMouseDown);
    game.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);

    // タッチ対応（簡易版）
    game.addEventListener('touchstart', e => {
      e.preventDefault();
      const touch = e.touches[0];
      const elem = document.elementFromPoint(touch.clientX, touch.clientY);
      onMouseDown({ target: elem });
    });
    game.addEventListener('touchmove', e => {
      e.preventDefault();
      const touch = e.touches[0];
      const elem = document.elementFromPoint(touch.clientX, touch.clientY);
      onMouseMove({ target: elem });
    });
    document.addEventListener('touchend', e => {
      e.preventDefault();
      onMouseUp();
    });
  </script>
</body>
</html>